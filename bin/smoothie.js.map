{"version":3,"sources":["../src/smoothie.js"],"names":[],"mappings":"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","file":"smoothie.js","sourcesContent":["class Smoothie {\n  constructor(\n    options = {\n      renderingEngine: PIXI,       //The rendering engine (Pixi)\n      renderer: undefined,         //The Pixi renderer you created in your application\n      rootContainer: undefined,    //The root Pixi display object (usually the `stage`)\n      updateFunction: undefined,   //A logic function that should be called every frame of the game loop\n      propertiesToInterpolate: [], //An array of properties that should be interpolated: \"position\", \"rotation\", \"scale\", \"size\", \"alpha\"\n      interpolate: true,           //A Boolean to turn interpolation on or off\n      fps: 60,                     //The frame rate at which the application's looping logic function should update\n      renderFps: undefined,        //The frame rate at which sprites should be rendered\n    }\n  ) {\n    if (options.renderingEngine === undefined) throw new Error(\"Please assign a rendering engine as Smoothie's renderingEngine option\"); \n\n    //Find out which rendering engine is being used (the default is Pixi)\n    this.renderingEngine = \"\";\n\n    //If the `renderingEngine` is Pixi, set up Pixi object aliases\n    if (options.renderingEngine.ParticleContainer && options.renderingEngine.Sprite) {\n      this.renderingEngine = \"pixi\";\n    }\n\n    //Check to make sure the user had supplied a renderer. If you're\n    //using Pixi, this should be the instantiated `renderer` object\n    //that you created in your main application\n    if (options.renderer === undefined) {\n      throw new Error(\"Please assign a renderer object as Smoothie's renderer option\");\n    } else {\n      this.renderer = options.renderer;\n    }\n\n\n    //Check to make sure the user has supplied a root container. This\n    //is the object is at the top of the display list heirarchy. If\n    //you're using Pixi, it would be a `Container` object, often by\n    //convention called the `stage`\n    if (options.rootContainer === undefined) {\n      throw new Error(\"Please assign a root container object (the stage) as Smoothie's rootContainer option\");\n    } else {\n      this.stage = options.rootContainer;\n    }\n\n    if (options.updateFunction === undefined) {\n      throw new Error(\"Please assign a function that you want to update on each frame as Smoothie's updateFunction option\");\n    } else {\n      this.updateFunction = options.updateFunction;\n    }\n\n    if (options.propertiesToInterpolate === undefined) {\n      this.propertiesToInterpolate = new Set([\"position\", \"rotation\"]); \n    } else {\n      this.propertiesToInterpolate = new Set(options.propertiesToInterpolate);\n    }\n\n    //The upper-limit frames per second that the game' logic update\n    //function should run at.\n    //Smoothie defaults to 60 fps.\n    if (options.fps !== undefined) {\n      this._fps = options.fps;\n    } else {\n      this._fps = undefined;\n    }\n\n    //Optionally Clamp the upper-limit frame rate at which sprites should render\n    if (options.renderFps !== undefined) {\n      this._renderFps = options.renderFps;\n    } else {\n      this._renderFps = undefined;\n    }\n    //Set sprite rendering position interpolation to\n    //`true` by default\n    if (options.interpolate === false) {\n      this.interpolate = false;\n    } else {\n      this.interpolate = true;\n    }\n\n    //A variable that can be used to pause and play Smoothie \n    this.paused = false;\n\n    //Private properties used to set the frame rate and figure out the interpolation values\n    this._startTime = Date.now();\n    this._frameDuration = 1000 / this._fps;\n    this._lag = 0;\n    this._lagOffset = 0;\n\n    this._renderStartTime = 0;\n    if (this._renderFps !== undefined) {\n      this._renderDuration = 1000 / this._renderFps;\n    }\n  }\n\n  //Getters and setters\n\n  //Fps\n  get fps() {return this._fps;}\n  set fps(value) {\n    this._fps = value;\n    this._frameDuration = 1000 / this._fps;\n  }\n \n  //renderFps\n  get renderFps() {return this._renderFps;}\n  set renderFps(value) {\n    this._renderFps = value;\n    this._renderDuration = 1000 / this._renderFps;\n  }\n\n  //`dt` (Delta time, the `this._lagOffset` value in Smoothie's code)\n  get dt() {return this._lagOffset;}\n\n  //Methods to pause and resume Smoothie\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    this.paused = false;\n  }\n\n  //The `start` method gets Smoothie's game loop running\n  start() {\n  \n    //Start the game loop\n    this.gameLoop();\n  }\n\n  //The core game loop\n  gameLoop(timestamp) {\n    requestAnimationFrame(this.gameLoop.bind(this));\n\n    //Only run if Smoothie isn't paused\n    if (!this.paused) {\n\n      //The `interpolate` function updates the logic function at the\n      //same rate as the user-defined fps, renders the sprites, with\n      //interpolation, at the maximum frame rate the system is capbale\n      //of\n\n      let interpolate = () => {\n\n        //Calculate the time that has elapsed since the last frame\n        let current = Date.now(),\n            elapsed = current - this._startTime;\n\n        //Catch any unexpectedly large frame rate spikes\n        if (elapsed > 1000) elapsed = this._frameDuration;\n\n        //For interpolation:\n        this._startTime = current;\n\n        //Add the elapsed time to the lag counter\n        this._lag += elapsed;\n\n        //Update the frame if the lag counter is greater than or\n        //equal to the frame duration\n        while (this._lag >= this._frameDuration){\n\n          //Capture the sprites' previous properties for rendering\n          //interpolation\n          this.capturePreviousSpriteProperties();\n\n          //Update the logic in the user-defined update function\n          this.updateFunction();\n\n          //Reduce the lag counter by the frame duration\n          this._lag -= this._frameDuration;\n        }\n\n        //Calculate the lag offset and use it to render the sprites\n        this._lagOffset = this._lag / this._frameDuration;\n        this.render(this._lagOffset);\n      };\n\n      //If the `fps` hasn't been defined, call the user-defined update \n      //function and render the sprites at the maximum rate the \n      //system is capable of\n      if (this._fps === undefined) {\n\n        //Run the user-defined game logic function each frame of the\n        //game at the maxium frame rate your system is capable of\n        this.updateFunction();\n        this.render();\n      } else {\n        if (this._renderFps === undefined){\n          interpolate();\n        } else {\n\n          //Implement optional frame rate rendering clamping\n          if(timestamp >= this._renderStartTime) {\n            \n            //Update the current logic frame and render with\n            //interpolation\n            interpolate();\n\n            //Reset the frame render start time\n            this._renderStartTime = timestamp + this._renderDuration;\n          }\n        }\n      }\n    }\n  }\n\n  //`capturePreviousSpritePositions`\n  //This function is run in the game loop just before the logic update\n  //to store all the sprites' previous positions from the last frame.\n  //It allows the render function to interpolate the sprite positions\n  //for ultra-smooth sprite rendering at any frame rate\n  capturePreviousSpriteProperties() {\n    \n    //A function that capture's the sprites properties\n    let setProperties = (sprite) => {\n      if(this.propertiesToInterpolate.has(\"position\")) {\n        sprite._previousX = sprite.x;\n        sprite._previousY = sprite.y;\n      }\n      if(this.propertiesToInterpolate.has(\"rotation\")) {\n        sprite._previousRotation = sprite.rotation;\n      }\n      if(this.propertiesToInterpolate.has(\"size\")) {\n        sprite._previousWidth = sprite.width;\n        sprite._previousHeight = sprite.height;\n      }\n      if(this.propertiesToInterpolate.has(\"scale\")) {\n        sprite._previousScaleX = sprite.scale.x;\n        sprite._previousScaleY = sprite.scale.y;\n      }\n      if(this.propertiesToInterpolate.has(\"alpha\")) {\n        sprite._previousAlpha = sprite.alpha;\n      }\n\n      if (sprite.children && sprite.children.length > 0) {\n        for (let i = 0; i < sprite.children.length; i++) {\n          let child = sprite.children[i];\n          setProperties(child);\n        } \n      }\n    };\n\n    //loop through the all the sprites and capture their properties\n    for (let i = 0; i < this.stage.children.length; i++) {\n      let sprite = this.stage.children[i];\n      setProperties(sprite);\n    } \n  }  \n\n  //Smoothie's `render` method will interpolate the sprite positions and\n  //rotation for\n  //ultra-smooth animation, if Hexi's `interpolate` property is `true`\n  //(it is by default)\n  render(lagOffset = 1) {\n\n    //Calculate the sprites' interpolated render positions if\n    //`this.interpolate` is `true` (It is true by default)\n\n    if (this.interpolate) {\n\n      //A recursive function that does the work of figuring out the\n      //interpolated positions\n      let interpolateSprite = (sprite) => {\n\n        //Position (`x` and `y` properties)\n        if(this.propertiesToInterpolate.has(\"position\")) {\n\n          //Capture the sprite's current x and y positions\n          sprite._currentX = sprite.x;\n          sprite._currentY = sprite.y;\n\n          //Figure out its interpolated positions\n          if (sprite._previousX !== undefined) {\n            sprite.x = (sprite.x - sprite._previousX) * lagOffset + sprite._previousX;\n          }\n          if (sprite._previousY !== undefined) {\n            sprite.y = (sprite.y - sprite._previousY) * lagOffset + sprite._previousY;\n          }\n        }\n\n        //Rotation (`rotation` property)\n        if(this.propertiesToInterpolate.has(\"rotation\")) {\n\n          //Capture the sprite's current rotation\n          sprite._currentRotation = sprite.rotation;\n\n          //Figure out its interpolated rotation\n          if (sprite._previousRotation !== undefined) {\n            sprite.rotation = (sprite.rotation - sprite._previousRotation) * lagOffset + sprite._previousRotation;\n          }\n        } \n\n        //Size (`width` and `height` properties)\n        if(this.propertiesToInterpolate.has(\"size\")) {\n\n          //Capture the sprite's current size\n          sprite._currentWidth = sprite.width;\n          sprite._currentHeight = sprite.height;\n\n          //Figure out the sprite's interpolated size\n          if (sprite._previousWidth !== undefined) {\n            sprite.width = (sprite.width - sprite._previousWidth) * lagOffset + sprite._previousWidth;\n          }\n          if (sprite._previousHeight !== undefined) {\n            sprite.height = (sprite.height - sprite._previousHeight) * lagOffset + sprite._previousHeight;\n          }\n        }\n\n        //Scale (`scale.x` and `scale.y` properties)\n        if(this.propertiesToInterpolate.has(\"scale\")) {\n          \n          //Capture the sprite's current scale\n          sprite._currentScaleX = sprite.scale.x;\n          sprite._currentScaleY = sprite.scale.y;\n\n          //Figure out the sprite's interpolated scale\n          if (sprite._previousScaleX !== undefined) {\n            sprite.scale.x = (sprite.scale.x - sprite._previousScaleX) * lagOffset + sprite._previousScaleX;\n          }\n          if (sprite._previousScaleY !== undefined) {\n            sprite.scale.y = (sprite.scale.y - sprite._previousScaleY) * lagOffset + sprite._previousScaleY;\n          }\n        }\n\n        //Alpha (`alpha` property)\n        if(this.propertiesToInterpolate.has(\"alpha\")) {\n\n          //Capture the sprite's current alpha\n          sprite._currentAlpha = sprite.alpha;\n\n          //Figure out its interpolated alpha\n          if (sprite._previousAlpha !== undefined) {\n            sprite.alpha = (sprite.alpha - sprite._previousAlpha) * lagOffset + sprite._previousAlpha;\n          }\n        } \n        \n        //Interpolate the sprite's children, if it has any\n        if (sprite.children.length !== 0) {\n          for (let j = 0; j < sprite.children.length; j++) {\n\n            //Find the sprite's child\n            let child = sprite.children[j];\n\n            //display the child\n            interpolateSprite(child);\n          }\n        }\n      };\n      \n      //loop through the all the sprites and interpolate them\n      for (let i = 0; i < this.stage.children.length; i++) {\n        let sprite = this.stage.children[i];\n        interpolateSprite(sprite);\n      } \n    }\n\n    //Render the stage. If the sprite positions have been\n    //interpolated, those position values will be used to render the\n    //sprite\n    this.renderer.render(this.stage);\n\n    //Restore the sprites' original x and y values if they've been\n    //interpolated for this frame\n    if (this.interpolate) {\n\n      //A recursive function that restores the sprite's original,\n      //uninterpolated x and y positions\n      let restoreSpriteProperties = (sprite) => {\n        if(this.propertiesToInterpolate.has(\"position\")) {\n          sprite.x = sprite._currentX;\n          sprite.y = sprite._currentY;\n        }\n        if(this.propertiesToInterpolate.has(\"rotation\")) {\n          sprite.rotation = sprite._currentRotation;\n        }\n        if(this.propertiesToInterpolate.has(\"size\")) {\n          sprite.width = sprite._currentWidth;\n          sprite.height = sprite._currentHeight;\n        }\n        if(this.propertiesToInterpolate.has(\"scale\")) {\n          sprite.scale.x = sprite._currentScaleX;\n          sprite.scale.y = sprite._currentScaleY;\n        }\n        if(this.propertiesToInterpolate.has(\"alpha\")) {\n          sprite.alpha = sprite._currentAlpha;\n        }\n\n        //Restore the sprite's children, if it has any\n        if (sprite.children.length !== 0) {\n          for (let i = 0; i < sprite.children.length; i++) {\n\n            //Find the sprite's child\n            let child = sprite.children[i];\n\n            //Restore the child sprite properties\n            restoreSpriteProperties(child);\n          }\n        }\n      };\n      for (let i = 0; i < this.stage.children.length; i++) {\n        let sprite = this.stage.children[i];\n        restoreSpriteProperties(sprite);\n      }\n    }\n  }  \n}\n"]}